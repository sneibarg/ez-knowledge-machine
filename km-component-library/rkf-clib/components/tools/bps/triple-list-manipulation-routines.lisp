;;
;; $Id: triple-list-manipulation-routines.lisp,v 1.80 2010/01/08 19:18:43 kbarker Exp $
;;

(unless (find-package :km) (make-package :km))
(in-package :km)
(setq *using-km-package* t)

;; CPL specific relations that can be ignored. Used by (remove-irrelevant-km-triple)s routine.
(defparameter *triple-relations-to-ignore* '(
  |det| |input-word| |marker| |query-varp| |equal| |grammatical-number| 
  |property-slot| |property| |/==| |count| |string-name|))

;;Concepts to be ignored.
(defparameter *triple-concepts-to-ignore* 
  '(|Property-Node| |Equation-Big-Node| |Big-Node| |Condition-Node|))

(defun get-all-triples-related-to-instance-list(instance-lst triple-lst)
  (let ((result 
	 (remove-duplicates 
	  (mappend #'(lambda(instance)
		       (sieve-triple-list-having-instance instance triple-lst))
		   instance-lst)
	  :test 'ps-triple-equal)))
    (if (set-equal (remove-duplicates instance-lst)
		   (remove-duplicates (extract-all-km-instances result)))
	result
      (get-all-triples-related-to-instance-list 
       (remove-duplicates (extract-all-km-instances result))
       triple-lst))
))

;;Test if some concept is to be ignored.
(defun concept-ignorep (input &optional(concepts-to-ignore *triple-concepts-to-ignore*))
  (let ((target-set (append concepts-to-ignore (mappend 'all-subclasses concepts-to-ignore))))
    (not (null (member input target-set)))))

;;takes in input from CPL, and filters out the cpl nl triples.
(defun remove-cpl-nl-triples (scenario compute-question yn-query)
  (values (remove-irrelevant-km-triples scenario)
	  compute-question
	  yn-query)
)

(defun strip-extraneous-triple-elems (triples)
  (if triples
      (if (listp triples)
          (let ((trip1 (car triples)))
            (if (non-nil-listp trip1)
                (cons (list (first trip1)
                            (second trip1)
                            (third trip1)
                      )
                      (strip-extraneous-triple-elems (cdr triples))
                )
                (cons trip1 (strip-extraneous-triple-elems (cdr triples)))
            )
          )
          triples
      )
  )
)

(defun non-nil-listp (inp)
  (and inp (listp inp))
)


;; Remove triples that are irrelevant. Triples containing house keeping information generated by CPL.
(defun remove-irrelevant-km-triples (triples 
				     &optional (relations-to-ignore  *triple-relations-to-ignore*)
				               (concepts-to-ignore *triple-concepts-to-ignore*))
  (strip-extraneous-triple-elems
    (remove-triples-with-unknown-objects
     (remove-if #'(lambda(triple)
		    (or (ignore-triple-with-relation? triple relations-to-ignore)
		        (and (instance-triple-p triple)
			     (concept-ignorep (triple-tail triple) 
					      concepts-to-ignore))))
	        triples)))
)

;;removes triples if head or tail instance(s) do not have corresponding instance-of triple.
(defun remove-triples-with-unknown-objects(triple-lst)
  (let ((all-instances (extract-all-km-instances (extract-instance-triples triple-lst))))
    (remove-if-not #'(lambda(triple)
		       (subsetp (extract-all-km-instances triple) all-instances))
		   triple-lst)))

;;Determine if triple is to be ignored based on its relation type.
(defun ignore-triple-with-relation?(triple &optional (relations-to-ignore *triple-relations-to-ignore*))
  (or (member (triple-relation triple) 
	      relations-to-ignore)
      (member (invert-slot (triple-relation triple))
	      relations-to-ignore)))

;;Routine to remove duplicate triples
(defun remove-duplicate-triples(triple-list)
  (remove-duplicates triple-list :test #'ps-triple-equal))

;;Return t if triples x and y are equal, i.e. x equal y or x equals y'
(defun ps-triple-equal(x y)
  (or (equal x y) 
      (equal x (invert-triple y))))

(defun sieve-triple-list-having-x-y(x y triple-list)
  (union
   (sieve-triple-list-having-head-tail x y triple-list)
   (sieve-triple-list-having-head-tail y x triple-list)
   :test 'ps-triple-equal))

(defun sieve-triple-list-having-head-tail(target-head target-tail triple-list)
  (sieve-triple-list-having-tail 
   target-tail
   (sieve-triple-list-having-head 
    target-head
    triple-list)))

;;Returns all triples having desired triple-head
(defun sieve-triple-list-having-head(target-head triple-list)
   (remove nil 
	   (mapcar #'(lambda (triple)
		       (let* ((head     (triple-head triple))
			      (relation (triple-relation triple))
			      (tail     (triple-tail triple)))
			 (if (equal head target-head)
			     triple)))
		  triple-list)))

;;Returns all triples not having triple-head
(defun sieve-triple-list-not-having-head(target-head triple-list)
   (remove nil 
	   (mapcar #'(lambda (triple)
		       (let* ((head     (triple-head triple))
			      (relation (triple-relation triple))
			      (tail     (triple-tail triple)))
			 (if (equal head target-head)
			     nil
			     triple)))
		  triple-list)))

;;Returns all triples not having triple-tail
(defun sieve-triple-list-not-having-tail(target-tail triple-list)
   (remove nil 
	   (mapcar #'(lambda (triple)
		       (let* ((head     (triple-head triple))
			      (relation (triple-relation triple))
			      (tail     (triple-tail triple)))
			 (if (equal tail target-tail)
			     nil
			     triple)))
		  triple-list)))

;;Returns all equation-set triples
(defun sieve-triple-list-for-eq-set-instances(triple-list)
  (mapcar #'(lambda (triple)
	      (triple-head triple))
	  (sieve-triple-list-having-tail '|Equation-Set|
					 (sieve-triple-list-having-relation '|instance-of| triple-list))))

;;Returns all triples having desired triple-tail
(defun sieve-triple-list-having-tail(target-tail triple-list)
   (remove nil 
	   (mapcar #'(lambda (triple)
		       (let* ((head     (triple-head triple))
			      (relation (triple-relation triple))
			      (tail     (triple-tail triple)))
			 (if (equal tail target-tail)
			     triple)))
		  triple-list)))

;;Returns all triples having desired triple-relation
(defun sieve-triple-list-having-relation(target-relation triple-list)
   (remove nil 
	   (mapcar #'(lambda (triple)
		       (let* ((head     (triple-head triple))
			      (relation (triple-relation triple))
			      (tail     (triple-tail triple)))
			 (if (equal relation target-relation)
			     triple)))
		  triple-list)))

;;Returns all triples having triple-relation
(defun sieve-triple-list-having-relation-list(target-relation-list triple-list)
  (cond ((null target-relation-list) ())
	 (t (append (sieve-triple-list-having-relation (car target-relation-list) triple-list)
		    (sieve-triple-list-having-relation-list 
		     (cdr target-relation-list) 
		     triple-list)))))
	 
;;Returns all triples not having desired triple-relation in target relation list
(defun sieve-triple-list-not-having-relation-list(target-relation-list triple-list)
  (cond ((null target-relation-list) triple-list)
	(t (sieve-triple-list-not-having-relation-list 
	    (cdr target-relation-list)
	    (sieve-triple-list-not-having-relation (car target-relation-list)
						   triple-list)))))

;;Returns all triples not having desired triple-relation
(defun sieve-triple-list-not-having-relation(target-relation triple-list)
   (remove nil 
	   (mapcar #'(lambda (triple)
		       (let* ((head     (triple-head     triple))
			      (relation (triple-relation triple))
			      (tail     (triple-tail     triple)))
			 (if (not (equal relation        target-relation))
			     triple)))
		   triple-list)))

;;Returns all triples containing KB instance either at triple-head or triple-tail
(defun sieve-triple-list-having-instance(target triple-list)
  (union (sieve-triple-list-having-head target triple-list)
	 (sieve-triple-list-having-tail target triple-list)
	 :test 'ps-triple-equal))

;;Returns all triples not containing KB instance either at triple-head or triple-tail
(defun sieve-triple-list-not-having-instance(target triple-list)
  (sieve-triple-list-not-having-head target
				     (sieve-triple-list-not-having-tail target 
									triple-list)))

(defun sieve-triple-list-not-having-instance-list(target-list triple-list)
  (cond ((null target-list) triple-list)
	(t (sieve-triple-list-not-having-instance-list (cdr target-list)
						       (sieve-triple-list-not-having-instance (car target-list)
											      triple-list)))))

(defun cluster-triple-list-having-head (head-list triple-list)
  (mapcar #'(lambda (instance-name)
	      (sieve-triple-list-having-head instance-name triple-list))
	  head-list))

;;Fixme, how about aggregates?
(defun extract-triple-head-from-triple-list(triple-list)
  (remove-duplicates 
   (remove nil
	   (mapcar #'(lambda (triple)
		       (triple-head triple))
		   triple-list))
   :test #'eql))

;;Fixme, how about aggregates?
(defun extract-triple-tail-from-triple-list(triple-list)
  (remove-duplicates 
   (remove nil
	   (mapcar #'(lambda (triple)
		       (triple-tail triple))
		   triple-list))
   :test #'eql))

(defun extract-triple-relation-from-triple-list(triple-list)
   (remove nil
	   (mapcar #'(lambda (triple)
		       (triple-relation triple))
		   triple-list)))

(defun get-unique-instance-count-for-triple-list(triple-list)
  (length 
   (extract-all-km-instances
    triple-list)))

;;Returns list of instances in triple-list, ordered by their dependency. 
;;least dependent(not referred by others) to most dependent(referred by others) concept
(defun extract-all-instances-from-triple-list-ordered-by-dependency(triple-list)
  (let* ((unsorted-km-assertion-lst (triples-to-km-assertions triple-list))
	 (skolem-assertions     (get-skolem-assertions unsorted-km-assertion-lst))
	 (non-skolem-assertions (order-km-assertions (extract-all-km-instances skolem-assertions)
						     (get-non-skolem-assertions unsorted-km-assertion-lst)))
	 (sorted-km-assertion-lst (append skolem-assertions non-skolem-assertions)))
    (reverse (mapcar #'(lambda(assertion)
		(car assertion))
	    sorted-km-assertion-lst))))

;;Flip triple whose tail is the intended-head. Otherwise return triple.
(defun flip-triple-to-have-head (intended-head triple)
  (if (equal intended-head (triple-tail triple))
      (invert-triple triple)
      triple))

;;Flips all triples in list whose tail is the intended-head. Otherwise return triple.
(defun flip-triple-list-to-have-head(intended-head triple-list)
  (mapcar #'(lambda (triple) (flip-triple-to-have-head intended-head triple))
	  triple-list))

;; a) has a different inverse slot
;; b) does not contain -of suffix                                                                                          
(defun forward-relationp(slot)
  (and (not (equal (invert-slot slot) slot))
       (not (-of-suffix-p (stringify slot)))))

;;returns t if str contains "-of" suffix.
(defun -of-suffix-p(str)
  (and (> (length str) 3)
       (string= (subseq str (- (length str) 3) (length str)) "-of")))

;;Triple relations are to be forward-pointing.
;;The function inverts a triple if the relation is not forward-pointing.
(defun make-triple-forward-pointing (triple)
  (let* ((head     (triple-head triple))
	 (relation (triple-relation triple))
	 (tail     (triple-tail triple)))
    (if (not (forward-relationp relation))
	(list tail (invert-slot relation) head)
        triple)))

;;Triple relations are to be forward-pointing.
;;The function inverts all triples whose relation is not forward-pointing.
(defun make-triple-proper (triple-list)
  (mapcar #'(lambda (triple)
	      (let* ((head     (triple-head triple))
		     (relation (triple-relation triple))
		     (tail     (triple-tail triple)))
		(if (not (instance-triple-p triple))
		    (make-triple-forward-pointing triple)
		    triple)))
	  triple-list))

;;Returns triples which do not have :triple prefixes, none of CPL triples, 
;;and also makes the resulting triples forward-pointing.
(defun get-simplified-km-triples(triple-list)
  (make-triple-proper
   (remove-irrelevant-km-triples 
    (strip-triple-prefix triple-list) 
    *triple-relations-to-ignore*)))

;;Returns all symbols bound to equation-set instances declared in triple list.
(defun extract-all-equation-symbol(triple-list)
  (flatten (mapcar #'(lambda(eq-set-inst)
		       (extract-equation-symbol-list-for-eq-set-inst eq-set-inst triple-list))
		   (sieve-triple-list-for-eq-set-instances triple-list))))

;;Returns the set of equation-expressions existing in triple list for an eq-set instance.
(defun extract-equation-expression-list-for-eq-set-inst(eq-set-inst triple-list)
    (mapcar #'(lambda (triple)
	      (triple-tail triple))
	  (sieve-triple-list-having-head eq-set-inst
					 (sieve-triple-list-having-relation '|equation-expression| triple-list))))

;;Returns the set of equation symbols existing in triple list for an eq-set instance.
(defun extract-equation-symbol-list-for-eq-set-inst(eq-set-inst triple-list)
    (mapcar #'(lambda (triple)
		(let* ((symbol-mapping (triple-tail triple))
		       (symbol         (second symbol-mapping))
		       (km-instance    (third  symbol-mapping)))
		  symbol))
	  (sieve-triple-list-having-head eq-set-inst
					 (sieve-triple-list-having-relation '|equation-symbol| triple-list))))

;;Returns triples having instance-of relation for symbol.
(defun extract-instance-triple-for-instance (input triple-list)
  (cond ((null input) nil)
	((atom input) (sieve-triple-list-having-head input (sieve-triple-list-having-relation '|instance-of| triple-list)))
	(t (append (extract-instance-triple-for-instance (car input) triple-list)
		   (extract-instance-triple-for-instance (cdr input) triple-list)))))

;;Returns subset of triples which have non instance-of relations
(defun extract-non-instance-triples(triple-list)
  (remove nil
	  (mapcar #'(lambda(triple)
		      (if (not (instance-triple-p triple)) triple))
		  triple-list)))

;;Returns subset of triples which have non instance-of relations
(defun extract-instance-triples(triple-list)
  (set-difference triple-list
		  (extract-non-instance-triples triple-list)))

;;Returns set of concepts for symbol instance in triple-list.
(defun get-concept-for-instance-in-triple-list(symbol triple-list)
  (let ((result (triple-tail (car (extract-instance-triple-for-instance symbol 
								      (aggregate-similar-relations triple-list))))))
    (cond ((consp result)
	   (remove-subsumers result))
	  (t (list result)))))

;;Returns set of instances for concept in triple-list
(defun get-all-instances-for-concept-in-triple-list (concept triple-list)
  (cond ((null concept) ())
	((atom concept)
	 (mapcar #'(lambda(triple)
		     (triple-head triple))
		 (sieve-triple-list-having-tail concept
						(extract-instance-triples triple-list))))))
	
;;Returns all referenced concepts in triple-list
(defun extract-all-concepts-in-triple-list(triple-list)
  (remove-duplicates (flatten (mapcar 'last (extract-instance-triples triple-list)))))

;;Aggregates the tails in triple-list
(defun aggregate-triple-tail(triple-list)
  (mapcar #'(lambda(triple)
	      (triple-tail triple))
	  triple-list))

;;Deaggregate instance-of triples into multiple triples
(defun deaggregate-instance-types (cpl-triples)
  (let (result)
    (dolist (cpl-triple cpl-triples)
      (cond
       ((and (eql (triple-relation cpl-triple) '|instance-of|) 
	     (consp (triple-tail cpl-triple)))
	(dolist (class (remove-subsumers (triple-tail cpl-triple)))
	  (push (list (triple-head cpl-triple) '|instance-of| class)
		result)))
       (t
	(push cpl-triple result))))
    result))

;;Tests if triple is an instance-of triple
(defun instance-triple-p(triple)
  (equal (triple-relation triple) '|instance-of|))

(defun extract-triples-not-having-root-slot(root slot triple-list)
  (remove nil 
	  (mapcar #'(lambda (triple)
		      (let ((head (triple-head triple))
			    (reln (triple-relation triple))
			    (tail (triple-tail triple)))
			(if (not (or (and (equal root head) 
					  (equal slot reln))
				     (and (equal root tail)
					  (equal slot (invert-slot reln)))))
			    triple)))
		  triple-list)))

;;Returns subset of triples for root and slot.
(defun extract-triples-for-root-slot(root slot triple-list)
  (remove-duplicate-triples
   (union (sieve-triple-list-having-head root
					 (sieve-triple-list-having-relation slot
									    triple-list))
	  (flip-triple-list-to-have-head root
					 (sieve-triple-list-having-tail root
									(sieve-triple-list-having-relation (invert-slot slot)
													   triple-list))))))

;;Returns all root and slot pairings in triple-list
;;Results computed for forward-pointing triples.
(defun get-all-root-slot-pairings(triple-list)
  (remove-duplicates 
   (mappend #'(lambda(triple)
		(list (list (triple-head triple)
			    (triple-relation triple))))
	    (extract-non-instance-triples 
	     (make-triple-proper triple-list)))
   :test 'equal))

;;Determines if instance participate as a slot filler in scenario graph
(defun instance-participate-as-slot-filler-p(instance scenario)
  (if (member instance (flatten (extract-triple-tail-from-triple-list scenario)))
      t))

;;Dominant instances are specialized instances that do not participate as a slot-filler
(defun get-dominant-instances (scenario)
  (let ((specialized-instances (get-all-specialized-instances scenario))
	(proper-triple-list    (make-triple-proper scenario)))
    (remove nil
	    (mapcar #'(lambda(instance)
			(if (null (instance-participate-as-slot-filler-p instance proper-triple-list))
			    instance))
	    specialized-instances))))

(defun remove-subsuming-instance-types(triple-list)
   (append
      (extract-non-instance-triples triple-list)
      (deaggregate-instance-types 
         (aggregate-similar-relations 
            (extract-instance-triples triple-list)))))

;;Tests if input is a triple.
(defun triple-p(input)
  (and (listp input)
       (= (length input) 3)
       (atom (triple-head input))
       (atom (triple-relation input))))

(defun extract-all-forward-pointing-triples-for-instance(instance scenario &optional(explored-instances nil))
  (if (not (member instance explored-instances))
      (let ((immediate-triples (get-immediate-triples-for-instance instance scenario)))
	(cond ((not (null immediate-triples))
	       (remove-duplicates 
		(append immediate-triples
			(extract-instance-triple-for-instance 
			 (cons instance (extract-all-km-instances
					 immediate-triples))
			 scenario)
			(mappend #'(lambda(x)
				     (extract-all-forward-pointing-triples-for-instance 
				      x 
				      scenario
				      (cons instance explored-instances)
				      ))
				 (extract-all-km-instances-from-triple-tail immediate-triples)))
		:test 'ps-triple-equal))
	      (t (extract-instance-triple-for-instance (list instance) scenario))))))

;;deprecated!
(defun extract-all-instances-from-triple-list(triple-list)
  (extract-all-km-instances triple-list))

;;Returns list of instances in triple-list
(defun extract-all-km-instances(input)
  (remove-if-not
   #'(lambda(x)
       (km-instancep x))
   (remove-duplicates (flatten (list input)))))

;;Returns list of constants in triple-list
;;Does not return Unit-of-Measurements.
(defun extract-all-km-constants(input)
  (remove-if-not
   'km-uom-constantp
   (remove-if-not
    'km-constantp
    (remove-duplicates 
     (flatten (list input))))))

(defun extract-all-km-instances-from-triple-tail(triple-list)
  (remove-duplicates
   (remove-if-not
    #'(lambda(x)
	(km-instancep x))
    (flatten (extract-triple-tail-from-triple-list triple-list)))))

(defun update-instances-in-triple-list (source-triples target-triples)
  (remove-duplicates 
   (append
    (extract-non-instance-triples target-triples)
    (extract-instance-triple-for-instance 
     (extract-all-km-instances target-triples)
     source-triples))
   :test 'ps-triple-equal))

(defun get-all-instances-in-triple-map-list(triple-map-list)
  (remove-duplicates
   (mappend #'(lambda(triple-map)
		(flatten
		 (append (get-mapping-source triple-map)
			 (get-mapping-target triple-map))))
	    triple-map-list)))

(defun all-instance-triple-p(input)
  (eval (cons 'and (mapcar #'(lambda (x) (instance-triple-p x)) input))))

(defun root-instance-p (instance triple-list)
  (zerop (get-in-edge-count instance triple-list) ))

(defun extract-all-root-instances-from-triple-list (triple-list)
  (remove-if-not #'(lambda(instance) 
		     (root-instance-p instance triple-list))
		 (extract-all-km-instances triple-list)))

(defun extract-all-non-property-value-root-instances-from-triple-list (triple-list)
  (remove-if #'(lambda(x)
		 (quasi-property-value-instance-p x triple-list))
	     (extract-all-root-instances-from-triple-list triple-list)))

(defun get-all-uoms-in-triple-list(triple-list)
  (remove-duplicates (mapcar 'cdr (get-uom-for-property-values-in-triple-list triple-list))))

(defun get-uom-for-property-values-in-triple-list(triple-list)
  (remove-duplicates
   (remove nil
	   (mapcar #'(lambda(triple)
		       (let ((head (triple-head triple))
			     (tail (triple-tail triple)))
			 (cond ((and (listp tail)
				     (equal (car tail) ':|pair|))
				(cons (car (quasi-get-concept-for-kb-instance head triple-list))
				      (car (last tail)))))))
		   (sieve-triple-list-having-relation '|value| triple-list)))))

(defun mirror-triple-list(triple-list)
  (append 
   (remove-duplicates triple-list :test 'ps-triple-equal)
   (invert-triple-list triple-list)))

(defun invert-triple-list(triple-list)
  (mapcar 'invert-triple
	  (remove-duplicates triple-list :test 'ps-triple-equal)))

(defun remove-reflexive-triples-from-triple-list(triple-list)
  (remove-if #'(lambda(triple)
		 (equal (triple-head triple) (triple-tail triple)))
	     triple-list))

(defun get-immediate-triples-for-instance(instance triple-list)
  (let ((target  (get-immediate-triples-for-instance0 instance triple-list)))
    (remove-duplicates 
     (append (extract-instance-triple-for-instance (extract-all-km-instances target)
						   triple-list)
	     target)
     :test 'triple-equal)))

(defun get-immediate-triples-for-instance0(instance scenario)
  (let* ((target-triples  (make-triple-proper 
			   (extract-non-instance-triples
			    (remove-irrelevant-km-triples scenario)))))
    (remove-duplicates (sieve-triple-list-having-head instance
						      target-triples)
		       :test 'ps-triple-equal)))

(defun get-slots-for-instance-in-triple-list(instance scenario)
   (extract-triple-relation-from-triple-list
    (sieve-triple-list-having-head instance scenario)))

(defun triple-list-equal(x y)
  (and 
   (subsetp x y :test 'ps-triple-equal)
   (subsetp y x :test 'ps-triple-equal)))

(defun get-clib-depth-for-triple-list(triple-list)
  (car (sort (mapcar 'abs-tax-dist-to-thing (mapcar 'triple-tail (extract-instance-triples triple-list)))
	     '>)))

(defun generalize-triples-to-clib-depth(triple-list depth &optional(concepts-to-ignore nil))
  (let ((instance-triples (extract-instance-triples triple-list))
	(non-instance-triples (extract-non-instance-triples triple-list)))
    (append (mappend #'(lambda(x)
			 (generalize-instance-triple x depth concepts-to-ignore))
		     instance-triples)
	    non-instance-triples)))

(defun generalize-instance-triple(triple depth &optional(concepts-to-ignore nil))
  (if (instance-triple-p triple)
      (let* ((concept-lst (flatten (triple-tail triple)))
	     (concept-hierarchy (append concept-lst (mappend 'all-superclasses concept-lst))))
	(mapcar #'(lambda(x)
		    (list (triple-head triple)
			  '|instance-of|
			  x))
		(remove-subsumers 
		 (append (intersection concept-hierarchy
				       concepts-to-ignore)
			 (remove-if #'(lambda(y) 
					(> (abs-tax-dist-to-thing y)
					   depth))
				    concept-hierarchy)))))
    triple))

;;Returns additional instance-of triples.
(defun isolate-triple (triple triple-lst)
  (quasi-properly-terminate-triple-list (list triple)
					triple-lst))

(defun isolate-all-triples(triple-lst)
  (mapcar #'(lambda(triple)
	      (isolate-triple triple triple-lst))
	  (extract-non-instance-triples triple-lst)))

(defun de-isolate-triple-grp(input)
  (mappend #'(lambda(x) x) input))

(defun properly-terminated-triple?(triple triple-lst)
  (eval
   (cons 'and
	 (mapcar #'(lambda (kb-instance)
		     (not (null (quasi-get-concept-for-kb-instance kb-instance triple-lst))))
		 (extract-all-km-instances triple)))))

(defun properly-terminated?(graph)
  (eval
   (cons 'and
	 (mapcar #'(lambda(triple)
		     (properly-terminated-triple? triple graph))
		   graph))))

(defun ps-update-instance-triples (input-triple-lst &optional(enable-classification? t))
  (let* ((triple-lst (affix-instance-triples input-triple-lst))
	 (other-triples (extract-non-instance-triples triple-lst))
	 (all-instances (reverse (extract-all-instances-from-triple-list-ordered-by-dependency triple-lst))))
    (dolist (inst all-instances)
      (ps-classify inst enable-classification?))
    (affix-instance-triples triple-lst)))

(defun affix-instance-triples(triple-lst)
  (append (generate-instance-triples (extract-all-instances-from-triple-list triple-lst))
	  (extract-non-instance-triples triple-lst)))

;;Checks if instance is triple-head for some instance-of triple in triple-lst
(defun triple-instance-p(instance triple-lst)
  (not (null (member instance (mapcar 'car (extract-instance-triples triple-lst))))))

;;Generalizes triple-head and triple-tail to be instance types, i.e., instance-of values for the km instance.
;;Only apply when triple-head and triple-tail are instances. Does not handle :pair, :seq, etc.
(defun type-triple-list(triple-lst)
  (let ((instance-concept-map (build-instance-concept-map triple-lst)))
    (mappend 'unfold-typed-triple
	     (mapcar #'(lambda(triple)
			 (replace-elements-in-list 
			  triple
			  instance-concept-map))
		     (extract-non-instance-triples
		      triple-lst)))))
  
(defun unfold-typed-triple(triple)
  (mappend #'(lambda(head)
	       (mapcar #'(lambda(tail)
			   (list head (triple-relation triple) tail))
		       (triple-tail triple)))
	   (triple-head triple)))

;;Checks if typed-triple violates domain/range
(defun check-type-triple(type-triple)
  (let* ((debug nil)
	 (reln (triple-relation type-triple)))
    (let ((result (and 
		   (not (null (member (triple-head type-triple)
			    (all-domains-of reln))))
		   (not (null (member (triple-tail type-triple)
				      (all-ranges-of reln)))))))
      (if (and debug
	       (null result))
	  (format t "~A violate domain/range~%" type-triple))
      result)))

;;Checks if typed-triple-list violates domain/range
(defun check-type-triple-list (type-triple-lst)
  (eval (cons 'and (mapcar 'check-type-triple type-triple-lst))))

;;Checks if triple-lst violates domain/range
(defun triple-lst-violate-domain/range?(triple-lst)
  (null (check-type-triple-list 
	 (type-triple-list 
	  (remove-irrelevant-km-triples triple-lst)))))

;;Clones triple-list graph
(defun ps-clone-triple-list (triples)
  (multiple-value-bind
      (orig->clone clone->orig)
      (generate-clone-pair-list 
       (extract-all-km-instances triples))
    (setq *CONTROLLER-UNCLONE-MAP* (append clone->orig
					   *CONTROLLER-UNCLONE-MAP*))
    (values (replace-elements-in-list triples orig->clone)
	    orig->clone
	    clone->orig)))

(defun ps-remove-constraint-triples(input-km-triples)
  (remove-if 'constraint-triple-p
	     input-km-triples))

(defun constraint-triple-p(triple)
  (not (null (intersection *constraint-keywords*
			   (flatten triple)))))

(defun extract-all-slots(triple-list)
  (remove-duplicates
   (mappend #'(lambda(triple)
		(list (triple-relation triple)
		      (invert-slot (triple-relation triple))))
	   triple-list)))

;;Two CMAP edges are ths same if they are
;; a) equal or
;; b) inverses of each other
(defun same-graph-edge(x y)
  (or (equal x y)
      (equal x (invert-slot y))))

(defun tag-instance(tag triple-lst)
  (replace-elements-in-list 
   triple-lst
   (mapcar #'(lambda(x)
	       (list x (intern (format nil "~A~A" x tag) :km)))
	   (extract-all-km-instances triple-lst))))

(defun seqify (lst)
  (cons ':|seq| lst))


(defun generalize-type-triple-list(triple-list depth &optional(concepts-to-ignore nil))
  (mappend #'(lambda(triple)
	       (let ((reln (triple-relation triple)))
		 (mappend #'(lambda(head)
			      (mapcar #'(lambda(tail)
					  (list head reln tail))
				      (generalize-concept-to-tax-dist 
				       (triple-tail triple)
				       depth
				       concepts-to-ignore)))
			  (generalize-concept-to-tax-dist
			   (triple-head triple)
			   depth
			   concepts-to-ignore))))
	   triple-list))

(defun build-instance-concept-map(triple-lst)
  (let* ((debug nil)
	 (instance-triples (extract-instance-triples triple-lst)))
    (let ((result 
	   (mapcar #'(lambda(instance) 
		       (progn 
			 (if debug (format t "#"))
			 (list instance (quasi-get-concept-for-kb-instance 
					 instance 
					 instance-triples))))
		   (extract-all-km-instances triple-lst))))
      (if debug (format t "~%"))
    result)))

;;returns all triples and their inverses, e.g.,  (X r Y), (Z r-of X)
(defun get-all-root-slot-for-triple-list(triple-list)
  (let ((semantic-triples (extract-non-instance-triples triple-list)))
    (remove-duplicates
     (mapcar #'(lambda(triple) (list (car triple)(cadr triple)))
	     (append semantic-triples
		     (invert-triple-list semantic-triples)))
     :test 'equal)))

;;Returns slot-filler instances inside multi-valued-slots.
(defun get-instances-inside-multi-valued-slots(triple-list)
  (remove-if #'(lambda(entry)
		 (or (null entry)
		     (= (length entry) 1)))
	     (mapcar #'(lambda(root-slot)
			 (let ((root (car root-slot))
			       (slot (cadr root-slot)))
			   (extract-all-km-instances 
			    (flatten 
			     (mapcar 'caddr 
				     (extract-triples-for-root-slot root slot triple-list))))))
		     (get-all-root-slot-for-triple-list triple-list))))

(defun deaggregate-triple(triple)
  (let ((head     (triple-head triple))
	(relation (triple-relation triple))
	(tail     (triple-tail triple)))
    (if (and (consp tail)
	     (not (km-aggregatep tail)))
	(mapcar #'(lambda(x)
		    (list head relation x))
		tail)
      (list (list head relation tail)))))

(defun deaggregate-triple-list(triple-lst)
  (cond ((null triple-lst) ())
	(t (append (deaggregate-triple      (car triple-lst))
		   (deaggregate-triple-list (cdr triple-lst))))))

(defun has-instance-triple-p(instance triple-list)
  (not (null (quasi-get-concept-for-kb-instance instance triple-list))))

#|

(defun testcase ()
  (multiple-value-bind
      (root graph)
      (ps-get-new-graph '|Mitosis|)
    (ps-remove-constraint-triples graph)))
   
|#

(defun expand-triple-list-diameter-by-one-edge(src-triple-lst original-triple-lst)
  (let* ((result 
	 (remove-duplicates
	  (quasi-properly-terminate-triple-list
	   (mappend #'(lambda(instance)
			(sieve-triple-list-having-instance 
			 instance 
			 original-triple-lst))
		    (extract-all-km-instances src-triple-lst))
	   original-triple-lst)
	  :test 'ps-triple-equal))
	 (additional-content-triples 
	  (set-difference 
	   (extract-non-instance-triples result)
	   (extract-non-instance-triples src-triple-lst)
	   :test 'ps-triple-equal)))
    (values result
	    additional-content-triples
	    (mapcar #'(lambda(additional-content-triple-entry)
			(remove-duplicates
			 (quasi-properly-terminate-triple-list
			  (cons additional-content-triple-entry
				src-triple-lst)
			  original-triple-lst)
			 :test 'ps-triple-equal))
		    additional-content-triples))))

;; (defun testme()
;;   (multiple-value-bind
;;       (root graph)
;;       (ps-get-graph '|Mitosis|)
;;     (expand-triple-list-diameter-by-one-edge
;;      `((,root |instance-of| |Mitosis|))
;;      graph)))

;; (expand-triple-list-diameter-by-one-edge
;;    '((|_Cell2002| |instance-of| |Cell|)
;;      (|_Volume2004| |instance-of| |Volume-Value|)
;;      (|_Cell2002| |volume| |_Volume2004|))
;;    '((|_Volume2004| |instance-of| |Volume-Value|)
;;      (|_Cell2002| |instance-of| |Cell|)
;;      (|_Volume2005| |instance-of| |Volume-Value|)
;;      (|_Cell2003| |instance-of| |Cell|)
;;      (|_Cell2002| |volume| |_Volume2004|)
;;      (|_Cell2003| |volume| |_Volume2005|)
;;      (|_Volume2005| |greater-than| |_Volume2004|)
;;      (|_Amount2010| |instance-of| |Quantity-Value|)
;;      (|_Cytoplasm2006| |instance-of| |Cytoplasm|)
;;      (|_Amount2011| |instance-of| |Quantity-Value|)
;;      (|_Cytoplasm2008| |instance-of| |Cytoplasm|)
;;      (|_Cytoplasm2006| |quantity| |_Amount2010|)
;;      (|_Cell2002| |encloses| |_Cytoplasm2006|)
;;      (|_Cytoplasm2008| |quantity| |_Amount2011|)
;;      (|_Cell2003| |encloses| |_Cytoplasm2008|)
;;      (|_Amount2011| |greater-than| |_Amount2010|)
;;      (|_Number2018| |instance-of| |Unitless-Value|)
;;      (|_Wrinkle2012| |instance-of| |Conceptual-Entity|)
;;      (|_Surface2013| |instance-of| |Artifact|)
;;      (|_Number2019| |instance-of| |Unitless-Value|)
;;      (|_Wrinkle2015| |instance-of| |Conceptual-Entity|)
;;      (|_Surface2016| |instance-of| |Artifact|)
;;      (|_Wrinkle2012| |number-of-elements| |_Number2018|)
;;      (|_Surface2013| |has-on-it| |_Wrinkle2012|)
;;      (|_Cell2003| |has-part| |_Surface2013|)
;;      (|_Wrinkle2015| |number-of-elements| |_Number2019|)
;;      (|_Surface2016| |has-on-it| |_Wrinkle2015|)
;;      (|_Cell2002| |has-part| |_Surface2016|)))
   

